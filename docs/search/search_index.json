{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Telegram Updater Documentations Telegram Updater is a .NET package written in C# that helps you receive updates from Telegram Bot Api. Updater is made to bring simplicity when working with telegram bots in .NET. Updaters uses Telegram.Bot as dependency to work with api. This a framework written on top of Telegram.Bot. TelegramUpdater requires you to use .NET Core 3.1 and above! TelegramUpdater is highly adjustable for any type of common SDKs in .NET Normal apps with no hosting Worker Service ASP .NET app ... Example of WorkerService using WorkerService; IHost host = Host.CreateDefaultBuilder(args) .ConfigureServices(services => { services.AddTelegramUpdater( \"BOT_TOKEN\", default, (builder) => builder .AddMessageHandler<SimpleMessageHandler>() ); }) .Build(); await host.RunAsync(); That's minimum the requirements, but there're a lot of customizations. Wait ...","title":"Home"},{"location":"#telegram-updater-documentations","text":"Telegram Updater is a .NET package written in C# that helps you receive updates from Telegram Bot Api. Updater is made to bring simplicity when working with telegram bots in .NET. Updaters uses Telegram.Bot as dependency to work with api. This a framework written on top of Telegram.Bot. TelegramUpdater requires you to use .NET Core 3.1 and above! TelegramUpdater is highly adjustable for any type of common SDKs in .NET Normal apps with no hosting Worker Service ASP .NET app ...","title":"Telegram Updater Documentations"},{"location":"#example-of-workerservice","text":"using WorkerService; IHost host = Host.CreateDefaultBuilder(args) .ConfigureServices(services => { services.AddTelegramUpdater( \"BOT_TOKEN\", default, (builder) => builder .AddMessageHandler<SimpleMessageHandler>() ); }) .Build(); await host.RunAsync(); That's minimum the requirements, but there're a lot of customizations. Wait ...","title":"Example of WorkerService"},{"location":"ZeroToHero/","text":"From zero to hero If it's first time your creating a telegram bot in c#, then you're in the right place. Here i'll start from zero to create a telegram bot. Api token The very first thing you need is an api token for your bot. It's super easy to get one! Head toward @BotFather , the father of all bots in telegram. /start the bot and send Command /newbot to the bot father. You'll be asked for a name and a username for your bot. You can change the name later, but username can't be changed! You're done! the api key is in the congrats message. It's something like 123456789:AAEBfa-pTNt4fC9O1_Gw3FD9ZnreySiWhc8 . Console app In this tutorial we create a dotnet console app. My .NET version is 6.x.x , so it's a .NET 6 Console app template. I Highly recommend you to use the newer version of dotnet. I assumed that you have dotnet 6 sdk installed on your system. Pick a directory of your choice and open a command line in it. Write following command and hit Enter: ```cmd dotnet new console ``` This will create a console app in current directory. Execute following command to test your app: ```cmd dotnet run Hello World ``` Congrats, you have successfully created a console app. Open file Program.cs into your favorite editor ( i suggest VSCode ), to see the code inside. It should be something like this: csharp // blah blah blah Console.WriteLine(\"Hello World\"); Install Updater (This package) Now in order to connect to the telegram bot api you can use Updater . Updater is available in Nuget . Open a terminal and execute following command to install updater from nuget. ```cmd dotnet add package TelegramUpdater ``` The updater should be installed now. You can try referencing it. csharp using TelegramUpdater; Run the app to see if it works. Setup Updater The most important class of this package is Updater . You can directly create an instance of it but for now we have something better: UpdaterBuilder . UpdaterBuilder is some kind of helper class to help you create your Updater in an easier way and with some necessary default options. 0. Step Zero Creating UpdaterBuilder . Reference TelegramUpdater csharp using TelegramUpdater; Create an instance of UpdaterBuilder csharp var builder = new UpdaterBuilder(\"BOT_TOKEN\") Replace BOT_TOKEN with you own token from step on. 1. Step One Set options. Call method StepOne of builder with no parameters to set default options. builder.StepOne(); There are a batch of options that you can modify. The method itself is fully documented. 2. Step Two This step is to set an ExceptionHandler which will track exceptions occurred while handling updates. Again you can call method StepTwo with no parameters for a default exception handler. builder.StepTwo(); Step There This step is to set an update handler. An update handler has two primary jobs. Choose the right update to handle. Of course you wanna handle some specified updates, not all of them. For instance you may want to handle a Message Update that has a /start command in it as Text . In TelegramUpdater we do this using filters. All filter are child classes of Filter</T> where T is the update type. Eg: Filter<Message> for Message updates. There is an static class called FilterCutify which contains a set of ready to use filters for you. Here we can use csharp FilterCutify.OnCommand(\"start\") to create a filter for text messages like: /start . Add following code in your file: csharp var myFilter = FilterCutify.OnCommand(\"start\"); Your filter is ready. Handle matched updates. After an update passed your filter, you have to handle it in a suitable way. For instance you may want to answer an /start Command with Started as text respond. Handling updates are done in callback functions. The callback function takes an instance of UpdateContainerAbs<T> as parameter. T is the update type ( UpdateContainerAbs<Message> for messages. ) Callback functions are all async and all should return a Task . Create a callback function: csharp static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } You need following namespaces. csharp using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; Your callback function is ready. Now you're ready to complete StepThere . Pass your filter and callback function to the StepThere method. var updater = builder.StepThree(HandleStartMessage, myFilter); StepThere Gives you an instance of Updater . Your code should looks like this so far: using TelegramUpdater; using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; var builder = new UpdaterBuilder(\"BOT_TOKEN\"); builder.StepOne(); builder.StepTwo(); var myFilter = FilterCutify.OnCommand(\"start\"); static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } var updater = builder.StepThree(HandleStartMessage, myFilter); Start Now all you need is to start the updater. await updater.Start(); await keyword is essential! Test it Head toward your bot and send /start command and see if it works. Full Code Here is the full code in a compact version. using TelegramUpdater; using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } var updater = new UpdaterBuilder(\"BOT_TOKEN\") .StepOne() .StepTwo() .StepThree(HandleStartMessage, FilterCutify.OnCommand(\"start\")); await updater.Start(); And a version of code without UpdaterBuilder using TelegramUpdater; using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; using Telegram.Bot; using TelegramUpdater.UpdateHandlers.SealedHandlers; static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } static Task HandleException(Updater updater, Exception exception) { Console.WriteLine(exception); return Task.CompletedTask; } var updater = new Updater(new TelegramBotClient(\"BOT_TOKEN\")); updater.AddExceptionHandler<Exception>(HandleException); updater.AddUpdateHandler( new MessageHandler( HandleStartMessage, FilterCutify.OnCommand(\"start\"))); await updater.Start();","title":"Zero to hero"},{"location":"ZeroToHero/#from-zero-to-hero","text":"If it's first time your creating a telegram bot in c#, then you're in the right place. Here i'll start from zero to create a telegram bot.","title":"From zero to hero"},{"location":"ZeroToHero/#api-token","text":"The very first thing you need is an api token for your bot. It's super easy to get one! Head toward @BotFather , the father of all bots in telegram. /start the bot and send Command /newbot to the bot father. You'll be asked for a name and a username for your bot. You can change the name later, but username can't be changed! You're done! the api key is in the congrats message. It's something like 123456789:AAEBfa-pTNt4fC9O1_Gw3FD9ZnreySiWhc8 .","title":"Api token"},{"location":"ZeroToHero/#console-app","text":"In this tutorial we create a dotnet console app. My .NET version is 6.x.x , so it's a .NET 6 Console app template. I Highly recommend you to use the newer version of dotnet. I assumed that you have dotnet 6 sdk installed on your system. Pick a directory of your choice and open a command line in it. Write following command and hit Enter: ```cmd dotnet new console ``` This will create a console app in current directory. Execute following command to test your app: ```cmd dotnet run Hello World ``` Congrats, you have successfully created a console app. Open file Program.cs into your favorite editor ( i suggest VSCode ), to see the code inside. It should be something like this: csharp // blah blah blah Console.WriteLine(\"Hello World\");","title":"Console app"},{"location":"ZeroToHero/#install-updater-this-package","text":"Now in order to connect to the telegram bot api you can use Updater . Updater is available in Nuget . Open a terminal and execute following command to install updater from nuget. ```cmd dotnet add package TelegramUpdater ``` The updater should be installed now. You can try referencing it. csharp using TelegramUpdater; Run the app to see if it works.","title":"Install Updater (This package)"},{"location":"ZeroToHero/#setup-updater","text":"The most important class of this package is Updater . You can directly create an instance of it but for now we have something better: UpdaterBuilder . UpdaterBuilder is some kind of helper class to help you create your Updater in an easier way and with some necessary default options.","title":"Setup Updater"},{"location":"ZeroToHero/#0-step-zero","text":"Creating UpdaterBuilder . Reference TelegramUpdater csharp using TelegramUpdater; Create an instance of UpdaterBuilder csharp var builder = new UpdaterBuilder(\"BOT_TOKEN\") Replace BOT_TOKEN with you own token from step on.","title":"0. Step Zero"},{"location":"ZeroToHero/#1-step-one","text":"Set options. Call method StepOne of builder with no parameters to set default options. builder.StepOne(); There are a batch of options that you can modify. The method itself is fully documented.","title":"1. Step One"},{"location":"ZeroToHero/#2-step-two","text":"This step is to set an ExceptionHandler which will track exceptions occurred while handling updates. Again you can call method StepTwo with no parameters for a default exception handler. builder.StepTwo();","title":"2. Step Two"},{"location":"ZeroToHero/#step-there","text":"This step is to set an update handler. An update handler has two primary jobs. Choose the right update to handle. Of course you wanna handle some specified updates, not all of them. For instance you may want to handle a Message Update that has a /start command in it as Text . In TelegramUpdater we do this using filters. All filter are child classes of Filter</T> where T is the update type. Eg: Filter<Message> for Message updates. There is an static class called FilterCutify which contains a set of ready to use filters for you. Here we can use csharp FilterCutify.OnCommand(\"start\") to create a filter for text messages like: /start . Add following code in your file: csharp var myFilter = FilterCutify.OnCommand(\"start\"); Your filter is ready. Handle matched updates. After an update passed your filter, you have to handle it in a suitable way. For instance you may want to answer an /start Command with Started as text respond. Handling updates are done in callback functions. The callback function takes an instance of UpdateContainerAbs<T> as parameter. T is the update type ( UpdateContainerAbs<Message> for messages. ) Callback functions are all async and all should return a Task . Create a callback function: csharp static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } You need following namespaces. csharp using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; Your callback function is ready. Now you're ready to complete StepThere . Pass your filter and callback function to the StepThere method. var updater = builder.StepThree(HandleStartMessage, myFilter); StepThere Gives you an instance of Updater . Your code should looks like this so far: using TelegramUpdater; using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; var builder = new UpdaterBuilder(\"BOT_TOKEN\"); builder.StepOne(); builder.StepTwo(); var myFilter = FilterCutify.OnCommand(\"start\"); static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } var updater = builder.StepThree(HandleStartMessage, myFilter);","title":"Step There"},{"location":"ZeroToHero/#start","text":"Now all you need is to start the updater. await updater.Start(); await keyword is essential!","title":"Start"},{"location":"ZeroToHero/#test-it","text":"Head toward your bot and send /start command and see if it works.","title":"Test it"},{"location":"ZeroToHero/#full-code","text":"Here is the full code in a compact version. using TelegramUpdater; using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } var updater = new UpdaterBuilder(\"BOT_TOKEN\") .StepOne() .StepTwo() .StepThree(HandleStartMessage, FilterCutify.OnCommand(\"start\")); await updater.Start(); And a version of code without UpdaterBuilder using TelegramUpdater; using Telegram.Bot.Types; using TelegramUpdater.UpdateContainer; using Telegram.Bot; using TelegramUpdater.UpdateHandlers.SealedHandlers; static async Task HandleStartMessage(UpdateContainerAbs<Message> updateContainer) { await updateContainer.Response(\"Started!\"); } static Task HandleException(Updater updater, Exception exception) { Console.WriteLine(exception); return Task.CompletedTask; } var updater = new Updater(new TelegramBotClient(\"BOT_TOKEN\")); updater.AddExceptionHandler<Exception>(HandleException); updater.AddUpdateHandler( new MessageHandler( HandleStartMessage, FilterCutify.OnCommand(\"start\"))); await updater.Start();","title":"Full Code"},{"location":"DifferentSdks/Console/","text":"","title":"Console app"},{"location":"FeaturesExplained/UpdaterClass/","text":"Updater class In telegram updater package, Updater class has a essential role and almost everything done within it. What's the duty By default, updater gets an instance of ITelegramBotClient and usew it to make api requests like getUpdates and ... Updater gets updates from telegram bot api, process and orders them and sends them to the handlers you specified. Constructor ITelegramBotClient : This is the instance of your bot client. UpdaterOptions : A set of options to customize the updater behavior. Available options int? MaxDegreeOfParallelism : Maximum number of allowed concurent update handling tasks. If the bot becomes to busy, the updater would try to limit the rate! so it doesn't let updates count that are being handled at same time gose more than this value. bool PerUserOneByOneProcess : This option indicates if user can have multiple updates that are being handled at the same time. By enabling this, user has to wait a request of him to finish then starts a new one. ILogger<Updater>? Logger : a logger! updater will create a default if you leave this empty. bool FlushUpdatesQueue : If the updater is reponseable for getting updates, it will tell that old pending updates should be ignored and updater should receive updates from now. UpdateType[] AllowedUpdates : An array of UpdateType to specify the allowed updates. Again If the updater is reponseable for getting updates! And a CancellationToken to cancel the jobs. IServiceProvider This argument is not required! but if you have a service collection available, Updater behavior improves when handling IScopedUpdateHandler s, for instance, DI will be available inside them and they will be a real scoped operations. Available methods Here we have a list of available methods directly from updater. Adding Update Handler There are two major methods for this. AddUpdateHandler(ISingletonUpdateHandler updateHandler) Use this to add a singleton update handler to the updater Singleton handlers are creating ones and by yourself. AddScopedHandler(IScopedHandlerContainer scopedHandlerContainer) Use this to add an scoped handler container to the updater. Every container contains an IScopedUpdateHandler and a Filter . Scoped handlers are created per each request any automatically by updater. If you passed an IServiceCollection to the updater costructor, then updater will use it to create scopes and new instances. and DI will be available! If there's a IServiceCollection , normal handlers won't work! Note You don't have to use this methods directly, but there are many extension methods available to make it easier. Adding Exception Handler AddExceptionHandler(IExceptionHandler exceptionHandler) Exception handler let you define a job for each type of exception that occurs inside a handler. Opening channels OpenChannel<T>(AbstractChannel<T> updateChannel, TimeSpan timeOut) This method allows you to wait for a specified update to come inside a handler, for instance you can send a button to the user and wait for him in place! AbstractChannel<T> updateChannel : This class helps updater find the right update using filters. TimeSpan timeOut : Maximum allowed waiting time. var msg = await container.Response($\"Are you ok? answer quick!\", replyMarkup: new InlineKeyboardMarkup( InlineKeyboardButton.WithCallbackData(\"Yes i'm OK!\", \"ok\"))); await container.ChannelUserClick(TimeSpan.FromSeconds(5), \"ok\") .IfNotNull(async answer => { await answer.Edit(text: \"Well ...\"); }) .Else(async _ => { await msg.Edit(\"Slow\"); }); ChannelUserClick is an extension method for OpenChannel . Start! using Start method you tell the updater to start the job! Here you can specify if this method should block or not, or the updater is reponseable for getting updates and ...","title":"Updater Class"},{"location":"FeaturesExplained/UpdaterClass/#updater-class","text":"In telegram updater package, Updater class has a essential role and almost everything done within it.","title":"Updater class"},{"location":"FeaturesExplained/UpdaterClass/#whats-the-duty","text":"By default, updater gets an instance of ITelegramBotClient and usew it to make api requests like getUpdates and ... Updater gets updates from telegram bot api, process and orders them and sends them to the handlers you specified.","title":"What's the duty"},{"location":"FeaturesExplained/UpdaterClass/#constructor","text":"ITelegramBotClient : This is the instance of your bot client. UpdaterOptions : A set of options to customize the updater behavior.","title":"Constructor"},{"location":"FeaturesExplained/UpdaterClass/#available-options","text":"int? MaxDegreeOfParallelism : Maximum number of allowed concurent update handling tasks. If the bot becomes to busy, the updater would try to limit the rate! so it doesn't let updates count that are being handled at same time gose more than this value. bool PerUserOneByOneProcess : This option indicates if user can have multiple updates that are being handled at the same time. By enabling this, user has to wait a request of him to finish then starts a new one. ILogger<Updater>? Logger : a logger! updater will create a default if you leave this empty. bool FlushUpdatesQueue : If the updater is reponseable for getting updates, it will tell that old pending updates should be ignored and updater should receive updates from now. UpdateType[] AllowedUpdates : An array of UpdateType to specify the allowed updates. Again If the updater is reponseable for getting updates! And a CancellationToken to cancel the jobs. IServiceProvider This argument is not required! but if you have a service collection available, Updater behavior improves when handling IScopedUpdateHandler s, for instance, DI will be available inside them and they will be a real scoped operations.","title":"Available options"},{"location":"FeaturesExplained/UpdaterClass/#available-methods","text":"Here we have a list of available methods directly from updater.","title":"Available methods"},{"location":"FeaturesExplained/UpdaterClass/#adding-update-handler","text":"There are two major methods for this. AddUpdateHandler(ISingletonUpdateHandler updateHandler) Use this to add a singleton update handler to the updater Singleton handlers are creating ones and by yourself. AddScopedHandler(IScopedHandlerContainer scopedHandlerContainer) Use this to add an scoped handler container to the updater. Every container contains an IScopedUpdateHandler and a Filter . Scoped handlers are created per each request any automatically by updater. If you passed an IServiceCollection to the updater costructor, then updater will use it to create scopes and new instances. and DI will be available! If there's a IServiceCollection , normal handlers won't work!","title":"Adding Update Handler"},{"location":"FeaturesExplained/UpdaterClass/#note","text":"You don't have to use this methods directly, but there are many extension methods available to make it easier.","title":"Note"},{"location":"FeaturesExplained/UpdaterClass/#adding-exception-handler","text":"AddExceptionHandler(IExceptionHandler exceptionHandler) Exception handler let you define a job for each type of exception that occurs inside a handler.","title":"Adding Exception Handler"},{"location":"FeaturesExplained/UpdaterClass/#opening-channels","text":"OpenChannel<T>(AbstractChannel<T> updateChannel, TimeSpan timeOut) This method allows you to wait for a specified update to come inside a handler, for instance you can send a button to the user and wait for him in place! AbstractChannel<T> updateChannel : This class helps updater find the right update using filters. TimeSpan timeOut : Maximum allowed waiting time. var msg = await container.Response($\"Are you ok? answer quick!\", replyMarkup: new InlineKeyboardMarkup( InlineKeyboardButton.WithCallbackData(\"Yes i'm OK!\", \"ok\"))); await container.ChannelUserClick(TimeSpan.FromSeconds(5), \"ok\") .IfNotNull(async answer => { await answer.Edit(text: \"Well ...\"); }) .Else(async _ => { await msg.Edit(\"Slow\"); }); ChannelUserClick is an extension method for OpenChannel .","title":"Opening channels"},{"location":"FeaturesExplained/UpdaterClass/#start","text":"using Start method you tell the updater to start the job! Here you can specify if this method should block or not, or the updater is reponseable for getting updates and ...","title":"Start!"}]}